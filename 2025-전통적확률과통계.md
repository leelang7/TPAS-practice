## 1. 팩토리얼

얼마 전 인터넷 상에서 화제가 되었던, 초등학생 수학 문제로 보는 “문과-이과 구분법” 을 아시나요?

`40-32/2 = ?`
의 정답은 무엇일까요?

초등학생은 이에 `4!`라고 대답했습니다. 이 초등학생의 답을 보고

이과생은 “잘 알고 있네.” 라고 했고,

문과생은 “역시 잘 모르는구나.” 라고 대답하고 있습니다.

혹시 여러분은 왜 이런지 아시겠나요? 이 유머는 문,이과 상관없이 팩토리얼(!) 에 대해서만 알면 되는데요. 한 번 4! 을 계산해보겠습니다.

그럼 이제 4명의 학생을 뽑는 경우의 수를 계산해보겠습니다. 첫 번째로는 4명을 모두 뽑을 수 있고, 두 번째에서는 첫 번째에서 뽑힌 학생을 제외한 3명, 세 번째에서는 첫,두 번째에서 뽑힌 학생을 제외한 2명, 마지막에서는 앞에서 뽑힌 3명을 제외한 1명이 남으므로 4!과 같습니다.

이렇게 n개의 요소들을 순서대로 배치하는 경우의 수를 팩토리얼로 구할 수 있습니다.

## 문제

fac 함수가 문제에서 의도한 값을 반환하도록 올바르게 구현해보세요.

fac 함수는 정수 하나를 받아, 그 정수의 팩토리얼을 계산한 값을 반환해줍니다.

팩토리얼의 정의는 다음과 같습니다.

```
0! = 1
n! = n * (n-1)!

```

#### 출력 예시

```
print(fac(4))
>>>24
print(fac(5))
>>>120
```

## 2. 순열

파이썬의 itertools 모듈에 있는 permutations함수를 이용해 순열을 계산해보도록 하겠습니다.

## 문제

#### 순열

`permutations` 을 사용하여 nPr을 계산하겠습니다.

수강생분들을 뽑아 경품 추첨을 하게 되었습니다! 참가한 학생은 6명인데, 이 중 2명에게 상품을 주려 합니다. 하지만, 등수마다 경품이 다릅니다.

6명의 학생 중 순서를 고려하여 2명을 뽑는 경우의 수는 `rank_per` 에, 몇 가지 인지 계산한 것은 `rank_per_num` 에 저장해보겠습니다.

```
rank_per = list(permutations(["가","나","다","라","마","바"],2))
rank_per_num = len(rank_per)

```

학생들의 이름은 자유롭게 설정하여도 상관 없습니다.

## 3. 조합

파이썬의 itertools 모듈에 있는 combinations 함수를 이용해 조합을 계산해보도록 하겠습니다.

## 문제

#### 조합

`combinations` 라는 함수를 사용하여 nCr을 계산해보겠습니다.

수강생분들을 뽑아 경품 추첨을 하게 되었습니다! 참가한 학생은 6명인데, 이 중 2명에게 상품을 주려 합니다.

그럼 순서를 고려하지 않고 6명 중 2명을 뽑는 경우의 수는 `rank_com` 에, 이 경우의 수가 몇 가지인지 계산해 `rank_com_num` 에 저장해보겠습니다.

```
rank_com = list(combinations(["가","나","다","라","마","바"],2))
rank_com_num = len(rank_com)

```

학생들의 이름은 자유롭게 설정하여도 상관 없습니다.

## 4. 중복순열

n개 중 r개를 중복을 허용하여 순서대로 나열하는 경우의 수를 출력해보도록 하겠습니다.

## 문제

#### 중복순열

지난 실습에서 순열을 계산하는 방법 `permutations` 을 사용하여 nPr을 계산해보았습니다.

이번에는 `product` 를 활용하여 중복순열 n∏r을 계산해보겠습니다.

자전거 비밀번호를 바꾸려고 합니다. A부터 E까지의 알파벳 5개 중 하나씩을 뽑아 3자리의 비밀번호를 만든다고 하면, 이에 대한 경우의 수는 몇 가지 일까요? 3자리 수는 1번째 자리 수에 온 알파벳이 두 번째, 세 번째 자리에 와도 됩니다.

3자리의 비밀번호중 A~E를 뽑은 것은 `re_per` 에, 몇 가지 인지 계산한 것은 `re_per_num` 에 저장해보겠습니다.

```
re_per = list(product(['A', 'B','C','D','E'], repeat = 3))
re_per_num = len(re_per)
```

## 5. 중복조합

n개 중 r개를 중복을 허용하여 순서와 상관 없이 나열하는 경우의 수를 출력해보도록 하겠습니다.

## 문제

#### 중복조합

지난 실습에서 조합을 계산하는 방법을 사용하여 n개 중 r개를 뽑을 수 있는 `combinations` 라는 함수를 사용해봤습니다. 이번에는 중복을 허용하여 뽑는 중복조합 `combinations_with_replacement` 를 활용하여 nHr을 계산해봅시다.

자전거 비밀번호를 바꾸려고 합니다. A부터 E까지의 알파벳 5개 중 3개를 뽑아 비밀번호를 만든다고 합니다. 근데 순서는 보고 나중에 정하려고 합니다. 이에 대한 경우의 수는 몇 가지 일까요?

그럼 순서를 고려하지 않고 5가지 중 3개를 중복 가능하여 뽑는 경우의 수는 `re_com` 에, 이 경우의 수가 몇 가지인지 계산해 `re_com_num` 에 저장해보겠습니다.

```
re_com = list(combinations_with_replacement(['A','B','C','D','E'], 3))
re_com_num = len(re_com)
```

## 6. 조건부 확률과 독립

어떤 조건을 주고 이에 대한 확률 값을 계산하여 조건에 따른 확률 값을 확인해보겠습니다. 그리고 독립인지도 확인해보겠습니다.

실제 데이터들은 어떤 조건이 만족하면 이런 결과가 나오는 경우가 많기 때문에 조건부 확률을 잘 계산해야 합니다.

## 문제

엘리스에서 수강생 여러분들 중 30명을 선택하여 임의로 설문조사를 했습니다.

Q1. 엘리스 토끼가 체셔보다 더 귀여운가요? 라는 질문에

A : 아니요. 체셔가 더 귀여워요

B : 네. 토끼가 더 귀여워요

Q2. 엘리스 토끼가 체셔보다 더 예쁜가요? 라는 질문에

A : 아니요. 체셔가 더 예뻐요

B : 네. 토끼가 더 예뻐요

응답지 두 개를 주었습니다.
두 가지 질문의 A,B 응답 확률은 0.5 라고 가정합니다.

| 모두 A 응답 | 하나는 A, 하나는 B응답 | 모두 B응답 |
| :---------- | :--------------------- | :--------- |
| 1/4         | 1/2                    | 1/4        |

조건부 확률을 사용하여 1번 문항에 A를 응답한 경우(사건A)에서 두 문항 모두에 A를 응답한 경우(사건B)의 확률을 구해보면
P(B|A) = P(B∩A)/P(A) = P(B)/P(A) = 1/2 이므로 직관적으로 납득할 수 있는 값입니다.

그렇다면 이와는 반대로, 최소 한 문항에 A를 응답한 경우(사건O) 일 때, 두 문항 모두에 A를 응답한 경우(사건B) 의 확률을 계산해보면 다른 결과가 나옵니다.
P(B|O) = P(B, O)/P(O) = P(B)/P(O) = 1/3

이러한 내용을 `random` 을 사용해서 각각의 질문에 임의로 학생들이 할 대답을 뽑는 함수 `random_answer`을 만들어보겠습니다.

```
def random_answer():
    return random.choice(["A", "B"])

```

이를 for 문과 if문을 활용하여 30명의 응답을 알아보고, 2번째 질문에 A라 응답한 학생수를 `answer_Q2`,

두 질문 모두에 A라 응답한 학생수를 `answer_Q1andQ2`,

둘 중 하나의 질문에 A라 응답한 학생수를 `answer_Q1orQ2` 에 카운트해 저장해보겠습니다.

```
for i in range(30):
    Q1 = random_answer()
    Q2 = random_answer()
    if Q2 == "A":
        answer_Q2 += 1
    if Q2 == "A" and Q1 == "A":
        answer_Q1andQ2 += 1
    if Q2 == "A" or Q1 == "A":
        answer_Q1orQ2 += 1

```

저장한 값을 바탕으로 P(B|A), P(B|O) 를 계산해 print 해보겠습니다.

```
print( "P(Q1 and Q2 | Q2 ):", answer_Q1andQ2/answer_Q2)
print( "P(Q1 and Q2 | Q1 or Q2 ):", answer_Q1andQ2/answer_Q1orQ2)

```

두 물음에 대한 대답은 독립일까요? 아닐까요?

## 7. 확률변수

무작위 랜덤 확률변수를 만들어보겠습니다. 확률분포는 4주차에서 구체적으로 다루게 되므로 이번 주차에서는 확률변수에 대한 실습으로 마무리하겠습니다!

파이썬에는 공정한 주사위의 면을 만드는 듯한 함수인 `Die` 함수가 있습니다. 이를 활용해서 유한한 확률변수를 만들어보겠습니다.

## 문제

1. `Die` 함수를 사용해 6개의 면이 있는 공정한 주사위의 확률변수를 만들어보고 분포도 확인해보겠습니다.

```
Die6 = Die('Die6', 6)
Die6_dict = density(Die6).dict

```

1. `given` 으로 조건을 주어 다시 확률변수를 만들어보겠습니다.
   3 초과의 면만 나오는 주사위를 만드는 조건을 `condi` 에 저장해보고 분포를 `condi_dict` 에서 확인해보겠습니다.

```
condi = given(Die6, Die6 > 3)
condi_dict = density(condi).dict
```

## 8. 이항분포

이산형 확률분포 중 하나인 이항분포를 따르는 확률질량함수와 누적분포함수를 확인해보고 샘플을 뽑아보겠습니다.

## 문제

Q1. 확률질량함수
성공의 횟수를 확률변수 X 로 두고, X~ Bin(n,p) 에 대한 분포를 그려보겠습니다.

1. n을 10개, p 를 0.3 개로 두고, `sp.stats.binom` 을 사용하여 `stat_bin` 에 저장해보겠습니다.

```
n, p = 10,  0.3
stat_bin = sp.stats.binom(n, p)

```

1. 이에 대한 확률질량함수를 그려보면

```
x_axis = np.arange(n + 1) 
plt.bar(x_axis, stat_bin.pmf(x_axis))

```

1의 확률을 0.3 으로 해뒀기 때문에 1이 3번 나오는 것이 그래프에서 가장 높은 질량을 차지하고 있는 것을 확인할 수 있습니다.

Q2. 누적분포함수
이항분포에 대한 누적분포함수를 그려보겠습니다. 위에서 코드만 `pmf` 를 `cdf`로 바꿔주면 됩니다.

```
x_axis = np.arange(n + 1) 
plt.bar(x_axis, stat_bin.cdf(x_axis))

```

Q3. 랜덤표본 추출
X는 성공의 횟수이므로, x = 0,1,…,n이 될 수 있습니다.
위에서 pmf 를 그려보았던 10번 시도하고 성공의 확률이 p=0.3을 따르는, 즉 X~bin(10,3) 인 분포를 **50번** 반복하여 성공의 횟수에 대한 랜덤표본을 확인해보고 이에 대한 표본평균을 계산해보겠습니다.

1. 반복값의 동일함을 위한 seed 설정

```
np.random.seed(seed = 0)

```

`seed`는 랜덤으로 표본추출 등을 할 때 재현성을 갖추기 위해 설정합니다.

1. 랜덤표본 추출
   표본을 추출하여 `random_bin` 에 저장해 확인해보겠습니다.

```
random_bin = np.random.binomial(n = 10,p=0.3, size = 50)

```

여기서 n을 1으로 주면, 베르누이 분포를 따르는 표본을 추출할 수 있습니다.

1. 평균계산
   앞 시간에서 배운 평균을 계산해 `bin_mean` 에 저장해보겠습니다.

```
bin_mean = np.mean(random_bin)

```

10번의 시도에 따른 성공의 확률을 0.3 으로 줬으니까, 평균도 3과 매우 가까운 것을 확인하실 수 있습니다.

## 9. 초기하분포

불량을 잡아내는데 유용하게 쓰이는 이산형 분포인 초기하분포의 확률질량함수를 확인해보겠습니다.

## 문제

공장에서 A공정에서는 모니터를 30개씩 생산하고 있습니다. 이 공정의 불량률을 검사하는데 양품이 25개, 불량품이 5개인 공정에서 10개의 모니터를 추출해 불량품인지 확인 해보겠습니다.

Q1. 확률질량함수

1. 양품이 25개, 불량품이 5개인 공정에서 10개의 모니터를 추출해 불량품인지 확인하여 `stat_hyp` 에 저장해보겠습니다.

```
[M, n, N] = [30, 5, 10]
stat_hyp = sp.stats.hypergeom(M, n, N)

```

1. 위의 `pmf`로 확률질량함수를 확인해보겠습니다.

```
x_axis = np.arange(n+1)
plt.bar(x_axis, stat_hyp.pmf(x_axis))

```

각각의 확률은 발견할 불량품의 개수입니다. 10개를 검사했을 때 2개의 불량품을 발견할 확률이 가장 큰 걸 확인할 수 있습니다.

Q2. 누적분포함수

`pmf`를 `cdf`로 변경만 해주면 누적분포함수를 확인할 수 있습니다.

```
x_axis = np.arange(n+1)
plt.bar(x_axis, stat_hyp.cdf(x_axis))

```

### Q3. 샘플링

X는 성공의 횟수이므로, x = 0,1,…,n이 될 수 있습니다.
위에서 pmf 를 그려보았던 양품이 25개, 불량품이 5개인 공정에서 10개의 모니터를 추출해 불량품인지 확인하는 과정을 **50번** 반복하여 샘플링 결과 양품의 개수에 대한 랜덤표본을 확인해보고 이에 대한 표본평균을 계산해보겠습니다.

1. 반복값의 동일함을 위한 seed 설정

```
np.random.seed(seed = 0)

```

`seed`는 랜덤으로 표본추출 등을 할 때 재현성을 갖추기 위해 설정합니다.

1. 샘플 추출
   샘플을 추출하여 `random_hyp` 에 저장해 확인해보겠습니다.

```
random_hyp = np.random.hypergeometric(ngood = 5, nbad= 25, nsample=10, size = 50)

```

ngood 에 우리가 관심이 있는 불량품의 개수를 넣어야 합니다. 영어가 bad이라고 해서 불량품의 개수를 bad 에 넣으면 반대의 결과가 나옵니다.

1. 평균계산
   앞 시간에서 배운 평균을 계산해 `hyp_mean` 에 저장해보겠습니다.

```
hyp_mean = np.mean(random_hyp)

```

평균이 2와 가까운 것을 확인하실 수 있습니다. 10개를 검사했을 때 2개정도의 불량품을 찾아낼 수 있습니다.

## 10. 균일분포

일정한 구간에서 임의로 선택된 수에 대한 확률분포이며 연속형 분포인 균일분포의 확률밀도함수를 확인해보겠습니다.

## 문제

0부터 1까지의 구간을 따르는 균일분포 X~uni(0,1) 에 대하여 알아보겠습니다.

### Q1. 확률밀도함수

1. 0부터 1까지의 구간에 속하는 값을 가질 수 있고 그 확률이 균일한 확률밀도함수를 확인하여 `stat_uni` 에 저장해보겠습니다.

```
stat_uni = sp.stats.uniform()

```

1. 위의 `pdf`로 확률밀도함수를 확인해보겠습니다.

```
x_axis = np.linspace(0, 1, 100)
plt.bar(x_axis, stat_uni.pdf(x_axis))

```

0과 1 사이의 구간에 속하는 값을 가질 확률이 동일한 분포이므로 직사각형의 형태가 나옵니다.

### Q2. 누적분포함수

확률밀도함수의 `pdf`를 `cdf`로 변경만 해주면 누적분포함수를 확인할 수 있습니다.

```
x_axis = np.linspace(0, 1, 100)
plt.bar(x_axis, stat_uni.cdf(x_axis))

```

+`np.linspace(0, 1, 100)` 는 0부터 1까지의 구간에서 **100개**의 숫자를 동일한 크기만큼 뽑아주는 함수입니다.

### Q3. 샘플링

0부터 1까지의 구간을 따르는 균일분포 X~uni(0,1) 에 대한 랜덤표본을 확인해보고 이에 대한 표본평균을 계산해보겠습니다.

1. 반복값의 동일함을 위한 seed 설정

```
np.random.seed(seed = 0)

```

`seed`는 랜덤으로 표본추출 등을 할 때 재현성을 갖추기 위해 설정합니다.

1. 샘플 추출
   샘플을 **100개** 추출하여 `random_uni` 에 저장해 확인해보겠습니다.

```
random_uni = np.random.uniform(0,1,100)

```

0부터 1까지의 구간에서 **100개**의 샘플을 추출합니다.

1. 평균계산
   앞 시간에서 배운 평균을 계산해 `uni_mean` 에 저장해보겠습니다.

```
uni_mean = np.mean(random_uni)

```

평균이 0.5와 매우 가까운 것을 확인하실 수 있습니다.

## 11. 정규분포

종 모양의 확률밀도함수를 갖는 분포로 여러 종류의 자료를 설명하는데 좋은 분포이며 연속형 분포인 정규분포의 확률밀도함수를 확인해보겠습니다.

## 문제

mu 가 0 이고 sigma 가 1인 정규분포인 표준정규분포 X~N(0, 1) 에 대하여 알아보겠습니다.

### Q1. 확률밀도함수

1. mu 가 0 이고 sigma 가 1인 표준정규분포의 확률밀도함수를 확인하여 `stat_nor` 에 저장해보겠습니다.

```
stat_nor = sp.stats.norm(0,1)

```

1. 위의 `pdf`로 확률밀도함수를 확인해보겠습니다.

```
x_axis = np.linspace(-3, 3, 100)
plt.bar(x_axis, stat_nor.pdf(x_axis))

```

평소에 많이 보시던 종형의 분포 형태가 나옵니다.

### Q2. 누적분포함수

확률밀도함수의 `pmf`를 `cdf`로 변경만 해주면 누적분포함수를 확인할 수 있습니다.

```
x_axis = np.linspace(-3, 3, 100)
plt.bar(x_axis, stat_nor.cdf(x_axis))

```

+`np.linspace(-3, 3, 100)` 는 -3부터 3까지의 구간에서 **100개**의 숫자를 동일한 크기만큼 뽑아주는 함수입니다. 표준정규분포의 그래프를 많이 보셨던 형태와 유사하게 하기 위해 임의로 -3,3 을 설정했습니다.

### Q3. 샘플링

표준정규분포 X~N(0,1) 에 대한 랜덤표본을 확인해보고 이에 대한 표본평균을 계산해보겠습니다.

1. 반복값의 동일함을 위한 seed 설정

```
np.random.seed(seed = 0)

```

`seed`는 랜덤으로 표본추출 등을 할 때 재현성을 갖추기 위해 설정합니다.

1. 샘플 추출
   샘플을 **100개** 추출하여 `random_nor` 에 저장해 확인해보겠습니다.

```
random_nor = np.random.normal(0,1,100)

```

표준정규분포에서 **100개**의 샘플을 추출합니다.

- 표준정규분포이므로 `np.random.normal(0,1,100)` 대신 `np.random.standard_normal(100)`을 사용해도 같은 기능을 합니다.

1. 평균계산
   앞 시간에서 배운 평균을 계산해 `nor_mean` 에 저장해보겠습니다.

```
nor_mean = np.mean(random_nor)

```

평균이 0과 매우 가까운 것을 확인하실 수 있습니다.

## 12. 이항 검정

이항 검정에 대한 가설을 설정하고, 검정을 해보겠습니다.
후라이드 치킨 종류를 선호하는 후라이드 파(0)와 양념 치킨 종류를 선호하는 양념파(1)가 있습니다. 이 치킨 선호 유형을 베르누이 확률분포로 결정되는 값이라고 가정하겠습니다.
새로 출시한 치킨을 선호하는 비율은 양념파와 후라이드파가 같다고 가정하므로 베르누이 확률분포의 모수는 0.5 입니다.

새로 출시한 치킨을 선호하는 사람 50명 중 30명이 양념파였을 때, “새로 출시된 치킨을 선호하는 사람은 양념파이다” 라고 주장할 수 있을까요? 이를 표본을 추출하여 유의수준 0.05를 기준으로 확인해보겠습니다.

귀무가설 : “새로 출시한 치킨을 선호하는 사람은 치킨 선호 유형과 연관이 없다 : p= 0.5” vs. 대립가설 : “새로 출시한 치킨을 선호하는 사람은 치킨 선호 유형과 연관이 있다 : p != 0.5”

## 문제

1. 추출한 표본 값의 동일함을 위한 seed 설정

```
np.random.seed(seed = 0)

```

`seed`는 랜덤으로 표본추출 등을 할 때 재현성을 갖추기 위해 설정합니다.

1. 표본 추출

귀무가설의 모수 p = 0.5 를 갖고 베르누이 분포를 따르므로 n = 1으로 두어 이를 따르는 표본을 10개 추출하여 `random_ber` 에 저장해 확인해보겠습니다.

```
random_ber = np.random.binomial(n = 1,p=0.5, size = 50)

```

그리고 추출한 표본 중 0이 아닌 개수, 여기서는 1의 개수를 뽑아 `n_ber` 에 저장해보겠습니다.

- 여기서 `np.count_nonzero()` 함수는 0이 아닌 값의 개수를 세어 주는 함수입니다. 베르누이 분포는 0 또는 1의 값만 나오므로 1의 값이 몇 개인지 세어줍니다.

```
n_ber = np.count_nonzero(random_ber)

```

1의 값은 30개입니다. 그렇다면 p = 0.6 일까요? 이를 검정해보겠습니다.

1. 이항 검정
   2)에서 추출한 표본을 가지고 이항검정을 해 `binom_test` 에 저장해보겠습니다.

```
binom_test = sp.stats.binom_test(n_ber, 50)

```

결과값인 유의확률이 0.05 보다 매우 크므로 귀무가설을 기각할 수 없습니다. 그러므로 새로 출시된 치킨을 선호하는 것은 후라이드파와 양념파에 상관이 없습니다. 즉, “새로 출시된 치킨을 선호하는 사람은 양념파이다” 라고 주장할 수 없습니다.

## 13. 모평균 가설검정

모평균 가설검정에 대한 가설을 설정하고, 검정을 해보겠습니다.
표준편차의 값을 알고 있는 정규분포의 표본에 대한 기댓값을 검정하는 방법이다. 단일 표본 z- 검정이라고도 하는데, 따로 함수ztest가 준비되어 있지 않으므로 직접 `ztest` 를 만들어보겠습니다.

“고양이”를 주인공으로 동영상을 촬영하여 올렸을 때, 한 달 동안 구독자 수를 100명 으로 늘릴 수 있다고 합니다. 이 때, 표준편차는 5임을 알고 있다고 가정합니다. 10명을 대상으로 고양이 주인공 동영상의 한 달 구독자 수를 조사하였더니, 평균이 “103.69” 이었다고 합니다.

고양이 주인공 동영상의 구독자 수의 모평균을 mu라고 하자. 위의 주장은 mu = 100 이므로 가설은
귀무가설 : ” mu = 100” vs. 대립가설 : ” mu != 100”

## 문제

1. 추출한 표본 값의 동일함을 위한 seed 설정

   ```
   np.random.seed(seed = 0)

   ```

   `seed`는 랜덤으로 표본추출 등을 할 때 재현성을 갖추기 위해 설정합니다.
2. 표본 추출
   귀무가설의 모수 mu = 100, sigma = 5 를 갖고 정규분포를 따르는 표본을 10개 표본을 추출하여 `random_nor` 에 저장해 확인해보겠습니다.

   ```
   random_nor = np.random.normal(100,5,10)

   ```

   추출한 표본으로 평균을 계산해 `nor_mean` 에 저장해보겠습니다.

   ```
   nor_mean = np.mean(random_nor)

   ```

   이를 확인해보니, 103.69가 나왔습니다. 그렇다면 대립가설인 mu != 100 이 맞을까요?
3. 모평균 가설 검정 함수 정의

   ```
   def ztest(stat, mu, sigma):
           z = (stat.mean() - mu) / (sigma / np.sqrt(len(stat)))
           return (2 * (1-sp.stats.norm.cdf(z)))

   ```
4. 모평균 가설 검정
   2번에서 추출한 표본을 가지고 모평균 가설 검정을 해 `mu_test` 에 저장해보겠습니다.

   ```
   mu_test = ztest(random_nor, 100, 5)

   ```
5. 귀무가설과 대립가설
   결과값인 유의확률이 0.05보다 크기 때문에, 대립 가설을 채택할 수 없습니다. 표준편차가 충분히 작기 때문에, 샘플의 평균은 100이 아니라고 볼 수 없기 때문입니다. 하지만, 표준편차를 더 크게 하여, 샘플의 값이 100보다 더 큰 차이를 보인다면, 샘플의 평균은 100이 아니라는 대립가설을 채택할 수 있을 것입니다.
   따라서 실습에서는 **대립가설이 채택되도록, 샘플의 표준편차**를 크게 수정해보세요. 유의확률이 0.05 이하가 되면 만점을 받을 수 있습니다.

## 참고

- 이전 버전의 코드와 지시사항으로 촬영된 영상에서는 `ztest` 함수를 직접 사용해보는 부분에서 표준편차(sigma) 값을 10으로 사용하고 있습니다.
- 이는 앞서 표준편차를 5로 가정한 부분과 다르기 때문에 이렇게 나온 유의확률이 0.05보다 크다는 것은 무의미한 결과입니다.
- 따라서 `ztest` 함수에서 사용하는 표준편차는 **현재는 5로 수정되어 있습니다.**
- 그리고 초기 10개의 표본값으로 귀무가설이 기각된 것 또한 표준편차와 관련된 부분이 아니라 충분한 개수로 샘플링 되지 못한 것이 문제라는 점 유의하세요.
